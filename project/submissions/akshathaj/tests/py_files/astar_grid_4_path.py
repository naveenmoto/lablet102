# -*- coding: utf-8 -*-
"""astar_grid_with_route

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WT0NPQbSc8Yz4R31ZNz12yYG5RhksjE1
"""

# Commented out IPython magic to ensure Python compatibility.
import time
import toml
import numpy as np
import matplotlib.pyplot as plt
from ref_trajectory import plot_smooth_route
from ref_trajectory import generate_trajectory as traj
from astar_4_path import gen_astar_path, plot_astar
from route_directions import make_route,euclidean
from collision_dwa import simulate_unicycle,track,plot_final_path,plot_wvk
from environment_setup import grid_from_map,place_obstacles,plot_environment,densify_grid
# %matplotlib inline

config_params = toml.load("config.toml")['params']
locals().update(config_params)

grid = np.load("astar_grid.npy")
start = (0,19)
goal = (19,19)
astar_path,extent_limits = gen_astar_path(grid,start,goal)
plot_astar(grid,start,goal,astar_path,extent_limits)

grid_dense = densify_grid(grid)
plot_astar(grid_dense,start,goal,astar_path,extent_limits)

route,corners,r = make_route(astar_path)
if astar_path[0][0] > astar_path[1][0]:
  t0 = np.pi
elif astar_path[0][0] < astar_path[1][0]:
  t0 = 0
elif astar_path[0][1] < astar_path[1][1]:
  t0 = np.pi/2
elif astar_path[0][1] < astar_path[1][1]:
  t0 = -np.pi/2

start_pose = (*start,t0)
ref_path = traj(route,r,start_pose).T
rx,ry,t = ref_path.T
plot_smooth_route(grid_dense,start,goal,astar_path,rx,ry,extent_limits)

pose = (*astar_path[0],0)
logs = []
path_index = 0
v, w = 0.0, 0.0
while path_index < len(astar_path)-1:
    t0 = time.time()
    local_ref_path = astar_path[path_index:path_index+pred_horizon]
    # update path_index using current pose and local_ref_path
    if euclidean(pose[:2],local_ref_path[-1][:2]) < goal_threshold*4*pred_horizon:
        path_index = path_index + 1
        local_ref_path = astar_path[path_index:path_index+pred_horizon]
    # get next command
    v, w = track(grid_dense,local_ref_path,pose,v,w)
    
    #simulate vehicle for 1 step
    # remember the function now returns a trajectory, not a single pose
    pose = simulate_unicycle(pose,v,w)[-1]
    
    #update logs
    logs.append([*pose, v, w, local_ref_path[-1]])
    t1 = time.time() #simplest way to time-profile your code
    print(f"idx:{path_index}, v:{v:0.3f}, w:{w:0.3f}, current pose: {pose}, tracking point:{local_ref_path[-1][:2]}, time:{(t1-t0) * 1000:0.1f}ms")

plot_final_path(grid_dense,ref_path,logs,extent_limits)

plot_wvk(logs)

